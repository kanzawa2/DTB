#!/usr/bin/env ruby
require 'io/wait'

class ActivityTrackerManager
  def initialize
    @records = []
    @trackers = []
  end

  def add_tracker(tracker)
    @trackers << tracker
    return self
  end

  def get_record
    @trackers.each{|t| @records << t.get_record if t.ready? }
    return @records.sort!.shift
  end

  def ready?
    return @records.present? || @trackers.any?(&:ready?)
  end

  def stop_track
    @trackers.each(&:stop_track)
  end
end

class ActivityTracker
  def initialize
    @io = exec_cmd
  end

  def get_record
    return factory_class.new(@io.gets)
  end

  def ready?
    return @io.ready?
  end

  def stop_track
    system "kill -9 #{@io.pid}"
  end

  def self.create(tracker_types)
    tracker_type = tracker_types.shift
    case tracker_type
    when :file_open
      tracker = FileOpenTracker
    when :file_close
      tracker = FileCloseTracker
    when :focus_change
      tracker = FocusChangeTracker
    when :accept_path_filter
      tracker = AcceptPathFilter
    when :ignore_path_filter
      tracker = IgnorePathFilter
    when :ignore_name_filter
      tracker = IgnoreNameFilter
    else
      raise "Unknown Tracker type"
    end
    return tracker_types.empty? ? tracker.new : tracker.new(self.create(tracker_types))
  end
end

class FileOpenTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo #{Rails.root}/lib/file_history_scripts/track_file_open")
  end

  def factory_class
    FileOpenRecord
  end
end

class FileCloseTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo #{Rails.root}/lib/file_history_scripts/track_file_close")
  end

  def factory_class
    FileCloseRecord
  end
end

class FocusChangeTracker < ActivityTracker
  def exec_cmd
    IO.popen("#{Rails.root}/lib/file_history_scripts/track_focus_change")
  end

  def factory_class
    return FocusChangeRecord
  end
end

class ActivityTrackerDecorator < ActivityTracker
  def initialize(tracker)
    @tracker = tracker
    @record = nil
    return self
  end

  def get_record
    record = @record
    @record = nil
    return record
  end

  def ready?
    while @record.nil?
      if @tracker.ready?
        @record = filter_record(@tracker.get_record)
      else
        return false
      end
    end
    return true
  end

  def stop_track
    @tracker.stop_track
  end
end

class AcceptPathFilter < ActivityTrackerDecorator
  def filter_record(record)
    paths = [
             "#{ENV["HOME"]}"
            ]

    paths.each do |path|
      return record if /^#{path}/ =~ record.path
    end
    return nil
  end
end

class IgnorePathFilter < ActivityTrackerDecorator
  def filter_record(record)
    paths = [
             "#{ENV["HOME"]}/.emacs.d",
             "#{ENV["HOME"]}/.CFUserTextEncoding",
             "#{ENV["HOME"]}/Library"
            ]

    paths.each do |path|
      return nil if /^#{path}/ =~ record.path
    end
    return record
  end
end

class IgnoreNameFilter < ActivityTrackerDecorator
  def filter_record(record)
    pnames = [
              "parentalcontrol",
              "coreservicesd",
              "basename",
              "ps",
              "discoveryd",
              "cfprefsd",
              "TweetDeck",
              "Slack",
              "System Events",
              "grep",
              "wc",
              "sh",
              "get_number_of_f",
              "osascript",
              "taskgated",
              "launchservicesd",
              "com.apple.appki",
              "cookied",
              "AddressBookSour",
              "mtmd",
              "ruby",
              "mds",
              "mdworker",
              "trustevaluation",
              "fontworker",
              "Finder"
             ]

    pnames.each do |pname|
      return nil if /^#{pname}/ =~ record.pname
    end
    return record
  end
end

class ActivityRecord
  include Comparable
  attr_reader :time, :record_type, :pid, :pname

  def parse_line(line)
    line.chomp!
    principle_record = line.split("|")
    principle_record[0] = Time.at(principle_record.first.to_i)
    return principle_record
  end

  def <=>(other)
    self.time <=> other.time
  end

  def same_process?(other)
    self.pid == other.pid
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}"
  end
end

class FileOpenRecord < ActivityRecord
  attr_reader :path, :fd

  def initialize(line)
    @time, @record_type, @pid, @pname, @path, @fd = parse_line(line)
  end

  def same_path?(other)
    self.path == other.path
  end

  def same_fd?(other)
    self.fd == other.fd
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@path}|#{@fd}"
  end
end

class FileCloseRecord < ActivityRecord
  attr_reader :fd

  def initialize(line)
    @time, @record_type, @pid, @pname, @fd = parse_line(line)
  end

  def same_fd?(other)
    self.fd == other.fd
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@fd}"
  end
end

class FocusChangeRecord < ActivityRecord
  attr_reader :window_number

  def initialize(line)
    @time, @record_type, @pid, @pname, @window_number = parse_line(line)
  end

  def same_window?(other)
    self.window_number == other.window_number
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@window_number}"
  end
end

class WatchingFile
  attr_reader :time, :pid, :pname, :path, :window_number

  def initialize(h)
    @time, @pid, @pname, @path, @window_number = h[:time], h[:pid], h[:pname], h[:path], h[:window_number]
  end

  def same_process?(other)
    self.pid == other.pid
  end

  def same_path?(other)
    self.path == other.path
  end

  def same_window?(other)
    self.window_number == other.window_number
  end
end

class FileHistoryFactory
  def initialize
    @file_open_records = []
    @watching_files = []
  end

  def receive_record(record)
    case record
    when FileOpenRecord
      add_record(record)
    when FileCloseRecord
      delete_record(record)
    when FocusChangeRecord
      end_watch(record)
      start_watch(record)
    end
  end

  private
  def add_record(file_open_record)
    if @file_open_records.select{|r| r.same_process?(file_open_record) && r.same_path?(file_open_record)}.empty?
      @file_open_records.push file_open_record
    end
  end

  def delete_record(file_close_record)
    @file_open_records.select!{|r| !r.same_process?(file_close_record)}
  end

  def start_watch(focus_change_record)
    @file_open_records.select{|r| r.same_process?(focus_change_record)}.each do |record|
      watching_file = WatchingFile.new({
        time:  focus_change_record.time,
        pid:   record.time,
        pname: record.pname,
        path:  record.path,
        window_number: focus_change_record.window_number
      })
      @watching_files.push watching_file
    end
  end

  def end_watch(focus_change_record)
    @watching_files.each do |file|
      fh = UnifiedHistory.create(
        path:         file.path,
        title:        file.path.split("/").last || file.path,
        type:         "FileHistory",
        start_time:   file.time,
        end_time:     focus_change_record.time
      )
      puts "history: #{fh.start_time}|#{fh.end_time}|#{fh.title}|#{fh.path}"
    end
    @watching_files.clear
  end
end

################################
# main
$file_open_processes_copy = []
atm = ActivityTrackerManager.new
atm.add_tracker(ActivityTracker.create([:accept_path_filter,
                                        :ignore_path_filter,
                                        :ignore_name_filter,
                                        :file_open]))
sleep 1
atm.add_tracker(ActivityTracker.create([:ignore_name_filter,
                                        :file_close]))
atm.add_tracker(ActivityTracker.create([:focus_change]))
fhf = FileHistoryFactory.new
while 1 do
  if atm.ready?
    record = atm.get_record
    record.print_record
    fhf.receive_record(record)
  end
  # sleep 1 #sec
end
