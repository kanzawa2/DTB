#!/usr/bin/env ruby
require 'io/wait'

class ActivityTrackerManager
  def initialize
    @records = []
    @trackers = []
  end

  def add_tracker(tracker)
    @trackers << tracker
    return self
  end

  def get_record
    @trackers.each{|t| @records << t.get_record if t.ready? }
    return @records.sort!.shift
  end

  def ready?
    return @records.present? || @trackers.any?(&:ready?)
  end

  def stop_track
    @trackers.each(&:stop_track)
  end
end

class ActivityTracker
  def initialize
    @io = exec_cmd
  end

  def get_record
    return factory_class.new(@io.gets)
  end

  def ready?
    return @io.ready?
  end

  def stop_track
    system "kill -9 #{@io.pid}"
  end

  def self.create(tracker_types)
    tracker_type = tracker_types.shift
    case tracker_type
    when :file_open
      tracker = FileOpenTracker
    when :file_close
      tracker = FileCloseTracker
    when :focus_change
      tracker = FocusChangeTracker
    when :accept_home_directory_filter
      tracker = AcceptHomeDirectoryFilter
    when :ignore_library_filter
      tracker = IgnoreLibraryFilter
    when :ignore_finder_filter
      tracker = IgnoreFinderFilter
    when :ignore_font_worker_filter
      tracker = IgnoreFontWorkerFilter
    when :ignore_truste_valuation_filter
      tracker = IgnoreTrusteValuationFilter
    when :ignore_mdworker_filter
      tracker = IgnoreMdworkerFilter
    when :ignore_mds_filter
      tracker = IgnoreMdsFilter
    when :ignore_ruby_filter
      tracker = IgnoreRubyFilter
    when :ignore_mtmd_filter
      tracker = IgnoreMtmdFilter
    when :ignore_address_book_mana_filter
      tracker = IgnoreAddressBookManaFilter
    when :ignore_address_book_sour_filter
      tracker = IgnoreAddressBookSourFilter
    when :ignore_cookied_filter
      tracker =  IgnoreCookiedFilter
    when :ignore_cfuser_text_encoding_filter
      tracker = IgnoreCFUserTextEncodingFilter
    when :ignore_com_apple_appki_filter
      tracker = IgnoreComAppleAppkiFilter
    when :ignore_emacsd_filter
      tracker = IgnoreEmacsdFilter
    when :ignore_launchservicesd_filter
      tracker = IgnoreLaunchServicesdFilter
    when :ignore_taskgated_filter
      tracker = IgnoreTaskGatedFilter
    when :ignore_get_title_of_fo_filter
      tracker = IgnoreGetTitleOfFoFilter
    when :accept_wathicng_file_filter
      tracker = AcceptWathicngFileFilter
    when :ignore_get_number_of_focused_window_filter
      tracker = IgnoreGetNumberOfFocusedWindowFilter
    else
      raise "Unknown Tracker type"
    end
    return tracker_types.empty? ? tracker.new : tracker.new(self.create(tracker_types))
  end
end

class FileOpenTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo #{Rails.root}/lib/file_history_scripts/track_file_open")
  end

  def factory_class
    FileOpenRecord
  end
end

class FileCloseTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo #{Rails.root}/lib/file_history_scripts/track_file_close")
  end

  def factory_class
    FileCloseRecord
  end
end

class FocusChangeTracker < ActivityTracker
  def exec_cmd
    IO.popen("#{Rails.root}/lib/file_history_scripts/track_focus_change")
  end

  def factory_class
    return FocusChangeRecord
  end
end

class ActivityTrackerDecorator < ActivityTracker
  def initialize(tracker)
    @tracker = tracker
    @record = nil
    return self
  end

  def get_record
    record = @record
    @record = nil
    return record
  end

  def ready?
    while @record.nil?
      if @tracker.ready?
        @record = filter_record(@tracker.get_record)
      else
        return false
      end
    end
    return true
  end

  def stop_track
    @tracker.stop_track
  end
end

class AcceptHomeDirectoryFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}/ =~ record.path ? record : nil
  end
end

class IgnoreLibraryFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/Library/ =~ record.path ? nil : record
  end
end

class IgnoreFinderFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^Finder$/ =~ record.pname ? nil : record
  end
end

class IgnoreFontWorkerFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^fontworker$/ =~ record.pname ? nil : record
  end
end

class IgnoreTrusteValuationFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^trustevaluation$/ =~ record.pname ? nil : record
  end
end

class IgnoreMdworkerFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mdworker$/ =~ record.pname ? nil : record
  end
end

class IgnoreMdsFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mds$/ =~ record.pname ? nil : record
  end
end

class IgnoreRubyFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^ruby$/ =~ record.pname ? nil : record
  end
end

class IgnoreMtmdFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mtmd$/ =~ record.pname ? nil : record
  end
end

class IgnoreAddressBookManaFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^AddressBookMana$/ =~ record.pname ? nil : record
  end
end

class IgnoreAddressBookSourFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^AddressBookSour$/ =~ record.pname ? nil : record
  end
end

class IgnoreCookiedFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^cookied$/ =~ record.pname ? nil : record
  end
end

class IgnoreCFUserTextEncodingFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/\.CFUserTextEncoding$/ =~ record.path ? nil : record
  end
end

class IgnoreComAppleAppkiFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^com\.apple\.appki$/ =~ record.pname ? nil : record
  end
end

class IgnoreEmacsdFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/\.emacs\.d/ =~ record.path ? nil : record
  end
end

class IgnoreLaunchServicesdFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^launchservicesd/ =~ record.pname ? nil : record
  end
end

class IgnoreTaskGatedFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^taskgated/ =~ record.pname ? nil : record
  end
end

class IgnoreTaskGatedFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^taskgated/ =~ record.pname ? nil : record
  end
end

class IgnoreGetTitleOfFoFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^get_title_of_fo/ =~ record.pname ? nil : record
  end
end

class AcceptWathicngFileFilter < ActivityTrackerDecorator
  def filter_record(record)
    return $file_open_processes_copy.any?{|p| p.pname == record.pname && p.pid == record.pid && p.fd == record.fd} ? record : nil
  end
end

class IgnoreGetNumberOfFocusedWindowFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^get_number_of_f/ =~ record.pname ? nil : record
  end
end

class ActivityRecord
  include Comparable
  attr_reader :time, :record_type, :pid, :pname

  def parse_line(line)
    line.chomp!
    principle_record = line.split("|")
    principle_record[0] = Time.at(principle_record.first.to_i)
    return principle_record
  end

  def <=>(other)
    self.time <=> other.time
  end

  def same_process?(other)
    self.pid == other.pid && self.pname == other.pname
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}"
  end
end

class FileOpenRecord < ActivityRecord
  attr_reader :path, :fd

  def initialize(line)
    @time, @record_type, @pid, @pname, @path, @fd = parse_line(line)
  end

  def same_path?(other)
    self.path == other.path
  end

  def same_fd?(other)
    self.fd == other.fd
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@path}|#{@fd}"
  end
end

class FileCloseRecord < ActivityRecord
  attr_reader :fd

  def initialize(line)
    @time, @record_type, @pid, @pname, @fd = parse_line(line)
  end

  def same_fd?(other)
    self.fd == other.fd
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@fd}"
  end
end

class FocusChangeRecord < ActivityRecord
  attr_reader :window_number

  def initialize(line)
    @time, @record_type, @pid, @pname, @window_number = parse_line(line)
  end

  def same_window?(other)
    self.window_number == other.window_number
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@window_number}"
  end
end

class WatchingFile
  attr_reader :time, :pid, :pname, :path, :window_number

  def initialize(h)
    @time, @pid, @pname, @path, @window_number = h[:time], h[:pid], h[:pname], h[:path], h[:window_number]
  end

  def same_process?(other)
    self.pid == other.pid && self.pname == other.pname
  end

  def same_path?(other)
    self.path == other.path
  end

  def same_window?(other)
    self.window_number == other.window_number
  end
end

class FileHistoryFactory
  def initialize
    @file_open_records = []
    @watching_files = []
  end

  def receive_record(record)
    case record
    when FileOpenRecord
      add_record(record)
    when FileCloseRecord
      delete_record(record)
    when FocusChangeRecord
      end_watch(record)
      start_watch(record)
    end
  end

  private
  def add_record(file_open_record)
    @file_open_records.push file_open_record
  end

  def delete_record(file_close_record)
    @file_open_records.select!{|r| !r.same_process?(file_close_record) }
  end

  def start_watch(focus_change_record)
    @file_open_records.select{|r| r.same_process?(focus_change_record)}.each do |record|
      watching_file = WatchingFile.new ({
        time:  focus_change_record.time,
        pid:   record.time,
        pname: record.pname,
        path:  record.path,
        window_number: focus_change_record.window_number
      })
      @watching_files.push watching_file
    end
  end

  def end_watch(focus_change_record)
    @watching_files.each do |file|
      fh = UnifiedHistory.create(
        path:         file.path,
        title:        file.path.split("/").last || file.path,
        history_type: "file_history",
        start_time:   file.time,
        end_time:     focus_change_record.time
      )
      puts "history: #{fh.start_time}|#{fh.end_time}|#{fh.title}|#{fh.path}"
    end
    @watching_files.clear
  end
end

################################
# main
$file_open_processes_copy = []
atm = ActivityTrackerManager.new
atm.add_tracker(ActivityTracker.create([:ignore_get_number_of_focused_window_filter,
                                        :ignore_get_title_of_fo_filter,
                                        :ignore_taskgated_filter,
                                        :ignore_launchservicesd_filter,
                                        :ignore_emacsd_filter,
                                        :ignore_com_apple_appki_filter,
                                        :ignore_cfuser_text_encoding_filter,
                                        :ignore_cookied_filter,
                                        :ignore_address_book_sour_filter,
                                        :ignore_address_book_mana_filter,
                                        :ignore_mtmd_filter,
                                        :ignore_ruby_filter,
                                        :ignore_mds_filter,
                                        :ignore_mdworker_filter,
                                        :ignore_truste_valuation_filter,
                                        :ignore_font_worker_filter,
                                        :ignore_finder_filter,
                                        :ignore_library_filter,
                                        :accept_home_directory_filter,
                                        :file_open]))
sleep 1
atm.add_tracker(ActivityTracker.create([:accept_wathicng_file_filter, :file_close]))
atm.add_tracker(ActivityTracker.create([:focus_change]))
fhf = FileHistoryFactory.new
while 1 do
  if atm.ready?
    record = atm.get_record
    record.print_record
    fhf.receive_record(record)
  end
  # sleep 1 #sec
end
