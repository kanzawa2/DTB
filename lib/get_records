#!/usr/bin/env ruby
require 'io/wait'

class ActivityTrackerManager
  def initialize
    @records = []
    @trackers = []
  end

  def add_tracker(tracker)
    @trackers << tracker
    return self
  end

  def get_record
    @trackers.each{|t|
      @records << t.get_record if t.ready?
    }
    oldest_record = @records.sort!.first
    @records[0] = nil
    @records.compact!
    return oldest_record
  end

  def ready?
    return !@records.empty? || @trackers.any?{|t| t.ready? }
  end

  def stop_track
    @trackers.each{|t|
      t.stop_track
    }
  end
end

class ActivityTracker
  def initialize
    @io = exec_cmd
  end

  def get_record
    return factory_class.new(@io.gets)
  end

  def ready?
    return @io.ready?
  end

  def stop_track
    system "kill -9 #{@io.pid}"
  end

  def self.create(tracker_types)
    tracker_type = tracker_types.shift
    case tracker_type
    when :file_open
      tracker = FileOpenTracker
    when :focus_change
      tracker = FocusChangeTracker
    when :accept_home_directory_filter
      tracker = AcceptHomeDirectoryFilter
    when :ignore_library_filter
      tracker = IgnoreLibraryFilter
    when :ignore_finder_filter
      tracker = IgnoreFinderFilter
    when :ignore_font_worker_filter
      tracker = IgnoreFontWorkerFilter
    when :ignore_truste_valuation_filter
      tracker = IgnoreTrusteValuationFilter
    when :ignore_mdworker_filter
      tracker = IgnoreMdworkerFilter
    when :ignore_mds_filter
      tracker = IgnoreMdsFilter
    when :ignore_ruby_filter
      tracker = IgnoreRubyFilter
    when :ignore_mtmd_filter
      tracker = IgnoreMtmdFilter
    when :ignore_address_book_mana_filter
      tracker = IgnoreAddressBookManaFilter
    when :ignore_address_book_sour_filter
      tracker = IgnoreAddressBookSourFilter
    when :ignore_cookied_filter
      tracker =  IgnoreCookiedFilter
    when :ignore_cfuser_text_encoding_filter
      tracker = IgnoreCFUserTextEncodingFilter
    when :ignore_com_apple_appki_filter
      tracker = IgnoreComAppleAppkiFilter
    when :ignore_emacsd_filter
      tracker = IgnoreEmacsdFilter
    else
      raise "Unknown Tracker type"
    end
    return tracker_types.empty? ? tracker.new : tracker.new(self.create(tracker_types))
  end
end

class FileOpenTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo #{Rails.root}/lib/track_file_open")
  end

  def factory_class
    FileOpenRecord
  end
end

class FocusChangeTracker < ActivityTracker
  def exec_cmd
    IO.popen("#{Rails.root}/lib/track_focus_change")
  end

  def factory_class
    return FocusChangeRecord
  end
end

class ActivityTrackerDecorator < ActivityTracker
  def initialize(tracker)
    @tracker = tracker
    @record = nil
    return self
  end

  def get_record
    record = @record
    @record = nil
    return record
  end

  def ready?
    while @record.nil?
      if @tracker.ready?
        @record = filter_record(@tracker.get_record)
      else
        return false
      end
    end
    return true
  end

  def stop_track
    tracker.stop_track
  end
end

class AcceptHomeDirectoryFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}/ =~ record.path ? record : nil
  end
end

class IgnoreLibraryFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/Library/ =~ record.path ? nil : record
  end
end

class IgnoreFinderFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^Finder$/ =~ record.pname ? nil : record
  end
end

class IgnoreFontWorkerFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^fontworker$/ =~ record.pname ? nil : record
  end
end

class IgnoreTrusteValuationFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^trustevaluation$/ =~ record.pname ? nil : record
  end
end

class IgnoreMdworkerFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mdworker$/ =~ record.pname ? nil : record
  end
end

class IgnoreMdsFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mds$/ =~ record.pname ? nil : record
  end
end

class IgnoreRubyFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^ruby$/ =~ record.pname ? nil : record
  end
end

class IgnoreMtmdFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^mtmd$/ =~ record.pname ? nil : record
  end
end

class IgnoreAddressBookManaFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^AddressBookMana$/ =~ record.pname ? nil : record
  end
end

class IgnoreAddressBookSourFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^AddressBookSour$/ =~ record.pname ? nil : record
  end
end

class IgnoreCookiedFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^cookied$/ =~ record.pname ? nil : record
  end
end

class IgnoreCFUserTextEncodingFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/\.CFUserTextEncoding$/ =~ record.path ? nil : record
  end
end

class IgnoreComAppleAppkiFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^com\.apple\.appki$/ =~ record.pname ? nil : record
  end
end

class IgnoreEmacsdFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}\/\.emacs\.d$/ =~ record.path ? nil : record
  end
end

class ActivityRecord
  include Comparable
  attr_reader :time, :record_type, :pid, :pname

  def parse_line(line)
    line.chomp!
    principle_record = line.split("|")
    principle_record[0] = Time.at(principle_record.first.to_i)
    return principle_record
  end

  def <=>(other)
    self.time <=> other.time
  end

  def equal_process?(other)
    self.pid == other.pid && self.pname == other.pname
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}"
  end
end

class FileOpenRecord < ActivityRecord
  attr_reader :path

  def initialize(line)
    @time, @record_type, @pid, @pname, @path = parse_line(line)
  end

  def equal_path?(other)
    self.path == other.path
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@path}"
  end
end

class FocusChangeRecord < ActivityRecord
  def initialize(line)
    @time, @record_type, @pid, @pname = parse_line(line)
  end
end

class FileOpeningProcess
  attr_reader :pid, :pname, :path

  def initialize(h)
    @pid, @pname, @path = h[:pid], h[:pname], h[:path]
  end

  def equal_process?(other)
    self.pid == other.pid && self.pname == other.pname
  end

  def equal_path?(other)
    self.path == other.path
  end
end

class WatchFileByProcess < ActivityRecord
  attr_reader :path
  def initialize(h)
    @time, @record_type, @pid, @pname, @path = h[:time], 'process', h[:pid], h[:pname], h[:path]
  end

  def equal_path?(other)
    self.path == other.path
  end
end

class FileHistoryFactory
  def initialize
    @file_opening_processes = []
    @watch_files = []
  end

  def create_history(record)
    case record
    when FileOpenRecord
      @file_opening_processes << FileOpeningProcess.new( pid:   record.pid,
                                                         pname: record.pname,
                                                         path:  record.path ) unless already_file_open_by_same_process?(record)
    when FocusChangeRecord
      start_watch_processes(record).each{|process|
        @watch_files << WatchFileByProcess.new( time:  record.time,
                                                pid:   process.pid,
                                                pname: process.pname,
                                                path:  process.path )
      }

      finish_watch_files(record).each{|f|
        fh = UnifiedHistory.create!( path:         f.path,
                                     title:        f.path.split("/").last || f.path,
                                     history_type: "file_history",
                                     start_time:   f.time,
                                     end_time:     record.time )
        puts "#{fh.start_time}|#{fh.end_time}|#{fh.title}|#{fh.path}"
      }
      @watch_files =  @watch_files.select{|f| f.equal_process?(record)}
    end
  end

  private

  def already_file_open_by_same_process?(record)
    return @file_opening_processes.any?{|p| p.equal_path?(record) && p.equal_process?(record)}
  end

  def start_watch_processes(focus_change_record)
    return @file_opening_processes.select{|p| p.equal_process?(focus_change_record)}
  end

  def finish_watch_files(focus_change_record)
    return @watch_files.select{|f| !f.equal_process?(focus_change_record)}
  end
end

################################
# main

atm = ActivityTrackerManager.new
atm.add_tracker(ActivityTracker.create([:ignore_emacsd_filter,
                                        :ignore_com_apple_appki_filter,
                                        :ignore_cfuser_text_encoding_filter,
                                        :ignore_cookied_filter,
                                        :ignore_address_book_sour_filter,
                                        :ignore_address_book_mana_filter,
                                        :ignore_mtmd_filter,
                                        :ignore_ruby_filter,
                                        :ignore_mds_filter,
                                        :ignore_mdworker_filter,
                                        :ignore_truste_valuation_filter,
                                        :ignore_font_worker_filter,
                                        :ignore_finder_filter,
                                        :ignore_library_filter,
                                        :accept_home_directory_filter,
                                        :file_open]))
atm.add_tracker(ActivityTracker.create([:focus_change]))
fhf = FileHistoryFactory.new
while 1 do
  if atm.ready?
    fhf.create_history(atm.get_record)
  end
  sleep 1 #sec
end
