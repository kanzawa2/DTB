#!/usr/bin/env ruby
require 'io/wait'

class ActivityTrackerManager
  def initialize
    @records = []
    @trackers = []
  end

  def add_tracker(tracker)
    @trackers << tracker
    return self
  end

  def get_record
    @trackers.each{|t|
      @records << t.get_record if t.ready?
    }
    oldest_record = @records.sort!.first
    @records[0] = nil
    @records.compact!
    return oldest_record
  end

  def ready?
    return !@records.empty? || @trackers.any?{|t| t.ready? }
  end

  def stop_track
    @trackers.each{|t|
      t.stop_track
    }
  end
end

class ActivityTracker
  def initialize
    @io = exec_cmd
  end

  def get_record
    return factory_class.new(@io.gets)
  end

  def ready?
    return @io.ready?
  end

  def stop_track
    system "kill -9 #{@io.pid}"
  end

  def self.create(tracker_types)
    tracker_type = tracker_types.shift
    case tracker_type
    when :file_open
      tracker = FileOpenTracker
    when :focus_change
      tracker = FocusChangeTracker
    when :home_directory_filter
      tracker = HomeDirectoryFilter
    else
      raise "Unknown Tracker type"
    end
    return tracker_types.empty? ? tracker.new : tracker.new(self.create(tracker_types))
  end
end

class FileOpenTracker < ActivityTracker
  def exec_cmd
    IO.popen("sudo ./track_file_open")
  end

  def factory_class
    FileOpenRecord
  end
end

class FocusChangeTracker < ActivityTracker
  def exec_cmd
    IO.popen("./track_focus_change")
  end

  def factory_class
    return FocusChangeRecord
  end
end

class ActivityTrackerDecorator < ActivityTracker
  def initialize(tracker)
    @tracker = tracker
    @record = nil
    return self
  end

  def get_record
    record = @record
    @record = nil
    return record
  end

  def ready?
    if @tracker.ready? && @record.nil?
      @record = @tracker.get_record
      @record = filter_record(@record)
    end
    return !@record.nil?
  end

  def stop_track
    tracker.stop_track
  end
end

class HomeDirectoryFilter < ActivityTrackerDecorator
  def filter_record(record)
    return /^#{ENV["HOME"]}/ =~ record.path ? record : nil
  end
end

class ActivityRecord
  include Comparable
  attr_reader :time, :record_type, :pid, :pname

  def parse_line(line)
    principle_record = line.split("|")
    principle_record[0] = Time.at(principle_record.first.to_i)
    return principle_record
  end

  def <=>(other)
    self.time <=> other.time
  end

  def equal_process?(other)
    self.pid == other.pid && self.pname == other.pname
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}"
  end
end

class FileOpenRecord < ActivityRecord
  attr_reader :path

  def initialize(line)
    @time, @record_type, @pid, @pname, @path = parse_line(line)
  end

  def print_record
    puts "#{@time}|#{@record_type}|#{@pid}|#{@pname}|#{@path}"
  end
end

class FocusChangeRecord < ActivityRecord
  def initialize(line)
    @time, @record_type, @pid, @pname = parse_line(line)
  end
end

################################
# main

rg = ActivityTrackerManager.new
rg.add_tracker(ActivityTracker.create([:home_directory_filter, :file_open])).add_tracker(ActivityTracker.create([:focus_change]))

while 1 do
  if rg.ready?
    record = rg.get_record
    record.print_record
  end
  sleep 1 #sec
end
